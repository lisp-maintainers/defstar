<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html>
<head>
<link rel="Stylesheet" type="text/css" href="cludg.css"/>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
<title>
defstar</title>
</head>
<body>
<div id="navbar">
<table cellspacing="0" cellpadding="0" border="0" style="width: 100%;">
<colgroup span="3">
<col width="0*"/>
<col width="0*"/>
<col width="1*"/>
</colgroup>
<tr>
<td align="left" valign="baseline">
<br/>
</td>
<td>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
<td align="left" valign="baseline">
<span class="upchain">
<b>
defstar</b>
<br/>
<a href="index.html">
Index</a>
</span>
&nbsp;&nbsp;&nbsp;&nbsp;</td>
</tr>
</table>
</div>
<div class="cludg-doc-body">
<h2>
defstar
</h2>
<table style="width: 100%;" class="summary-table">
<tr class="table-heading-color">
<th class="summary" colspan="2">
Constant summary</th>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g6">
+defun*-arrow-symbol+</a>
</td>
<td class="summary">
'-&gt;</td>
</tr>
</table>
<table style="width: 100%;" class="summary-table">
<tr class="table-heading-color">
<th class="summary" colspan="2">
Function summary</th>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g5">
defstar/ampersand-symbol?</a>
</td>
<td class="summary">
sym</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g4">
defstar/make-keyword</a>
</td>
<td class="summary">
<em>&amp;rest</em> parts</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g3">
defstar/split-defun-body</a>
</td>
<td class="summary">
body</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g8">
defun*-term</a>
</td>
<td class="summary">
term last-amp-kwd <em>&amp;key</em> (def-type 'defun)</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g9">
safe-define</a>
</td>
<td class="summary">
toplevel-form-name fname arglist body</td>
</tr>
</table>
<table style="width: 100%;" class="summary-table">
<tr class="table-heading-color">
<th class="summary" colspan="2">
Macro summary</th>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g13">
defgeneric*</a>
</td>
<td class="summary">
fname generic-arglist <em>&amp;body</em> options</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g12">
defmethod*</a>
</td>
<td class="summary">
fname method-arglist <em>&amp;body</em> body</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g15">
defparameter*</a>
</td>
<td class="summary">
var value <em>&amp;optional</em> docstring</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g11">
defun*</a>
</td>
<td class="summary">
fname arglist <em>&amp;body</em> body</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g14">
defvar*</a>
</td>
<td class="summary">
var value <em>&amp;optional</em> docstring</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g10">
defvar/param</a>
</td>
<td class="summary">
toplevel-form-name var value <em>&amp;optional</em> docstring</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g16">
flet*</a>
</td>
<td class="summary">
clauses <em>&amp;body</em> body</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g17">
labels*</a>
</td>
<td class="summary">
clauses <em>&amp;body</em> body</td>
</tr>
<tr class="table-row-color">
<td class="summary-name">
<a href="defstar.html#_g18">
lambda*</a>
</td>
<td class="summary">
arglist <em>&amp;body</em> body</td>
</tr>
</table>
<div class="defpackage">
<div class="defunsignatures">
<a id="_g2">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
DEFSTAR&nbsp;&nbsp;</td>
<td class="lambda-list">
</td>
<td class="symbol-type">
&nbsp;[Package]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Description: </h4>
<p>
DEFSTAR is a collection of macros that can be used in place 
 of DEFUN, DEFMETHOD, DEFGENERIC, DEFVAR, DEFPARAMETER, FLET, LABELS and LAMBDA. Each 
 macro has the same name as the form it replaces, with a star added at the 
 end (e.g. DEFUN*). 
 </p>
<p>
DEFSTAR's home is at: 
 </p>
<ul>
<li>
<p>
<a href="http://bitbucket.org/eeeickythump/defstar/">
http://bitbucket.org/eeeickythump/defstar/</a>

 </p>
</li>
</ul>
<p>
Installation requires ASDF. DEFSTAR does not depend on any other libraries. 
 </p>
<p>
The macros allow: 
 </p>
<ul>
<li>
<p>
easy inclusion of type declarations within lambda lists 
 </p>
</li>
<li>
<p>
easy inclusion of return type declarations in function and method definitions 
 </p>
</li>
<li>
<p>
easy inclusion of assertions for each argument and for the function's 
 return value 
 </p>
</li>
</ul>
<p>
See <a href="defstar.html#_g11">
defun*</a>
and <a href="defstar.html#_g14">
defvar*</a>
for a detailed 
 description of syntax. See also the examples below. 
 </p>
<p>
</p>
<h4>
Type DECLARATION versus type CHECKING: </h4>
<p>
Technically, DECLARE, DECLAIM and the like do not actually check that 
 values stored in the associated variables conform to the declared type. 
 They merely constitute a promise BY THE PROGRAMMER that only values of 
 the specified type will be stored there. The consequences of storing 
 a string in a variable that is declared to be of type integer, are 
 technically 'undefined'. 
 </p>
<p>
In practice, most modern Common Lisp implementations perform type-checking 
 based on declaration information, especially when SAFETY is high. 
 </p>
<p>
DEFSTAR allows you to force lisp to perform type checking based on 
 declarations. If you set the global variable 
 {defvar defstar:*CHECK-ARGUMENT-TYPES-EXPLICITLY?*}
 to non-nil, CHECK-TYPE forms will included in the body of each function 
 or method, causing an error to be raised if a value does not match 
 its declared type. 
 </p>
<p>
</p>
<h4>
Examples of DEFUN* and DEFMETHOD* usage: </h4>
<pre>
    ;; Define a simple function that adds two numbers, both of which 
     ;; are declared to be real. 
     (defun* sum ((a real) (b real)) 
        (+ a b)) </pre>
<p>
</p>
<pre>
    ;; Now also declare that the function returns a real. 
     (defun* (sum -&gt; real) ((a real) (b real)) 
        (+ a b)) </pre>
<p>
</p>
<pre>
    ;; Another way of declaring the function's return type. 
     (defun* sum ((a real) (b real)) 
        (returns real) 
        (+ a b)) </pre>
<p>
</p>
<pre>
    ;; We want to ensure that a and b are never negative. 
     ;; One way is to alter the type declarations: 
     (defun* (sum -&gt; (real 0)) ((a (real 0)) (b (real 0))) 
        (+ a b)) </pre>
<p>
</p>
<pre>
    ;; Another way is to define a new type: 
     (deftype natural () '(real 0)) 
     (defun* (sum -&gt; natural) ((a natural) (b natural)) 
        (+ a b)) </pre>
<p>
</p>
<pre>
    ;; Another way is to use assertions: 
     (defun* (sum -&gt; real (&gt;= return-value 0)) ((a real (&gt;= a 0)) (b real (&gt;= b 0))) 
        (+ a b)) </pre>
<p>
</p>
<pre>
    ;; Or: 
     (defun* sum ((a real (&gt;= a 0)) (b real (&gt;= b 0))) 
        (returns real (&gt;= return-value 0)) 
        (+ a b)) </pre>
<p>
</p>
<pre>
    ;; Or, using the feature that the names of single-argument predicate 
     ;; functions can be used as assertions: 
     (defun* (naturalp -&gt; boolean) ((x real)) 
        (not (minusp x))) 
     ... 
     (defun* (sum -&gt; real naturalp) ((a real naturalp) (b real naturalp)) 
        (+ a b)) </pre>
<p>
</p>
<pre>
    ;; A function that returns multiple values. 
     (defun* (floor -&gt; (values integer integer)) ((n real) (d real)) 
        (cl:floor n d)) </pre>
<p>
</p>
<pre>
    ;; It is possible to use assertions with functions that return 
     ;; multiple values. When a function is declared to return multiple 
     ;; values, RETURN-VALUE will be bound to a LIST of those values. 
     (defun* floor ((n real) (d real)) 
        (returns (values integer integer) 
                 (&lt; (second return-value) (first return-value))) 
        (cl:floor n d)) </pre>
<p>
</p>
<pre>
    ;; To declare that a function returns an unspecified number of 
     ;; values, of unspecified types: 
     (defun* (floor -&gt; (values)) ((n real) (d real)) 
        ...) </pre>
<p>
</p>
<pre>
    ;; The type of a &amp;REST argument can be declared. The declaration 
     ;; refers to the types of each element in the list of arguments 
     ;; stored in the &amp;REST argument. 
     (defun* (+ -&gt; real) (&amp;rest (numbers real)) 
        (apply #'cl:+ numbers)) </pre>
<p>
</p>
<pre>
    ;; More complicated lambda list. 
     ;; Note that the function and its first argument do not have type 
     ;; declarations. 
     ;; Also note the syntax of typed keyword arguments: 
     ;; ((var TYPE [ASSERTION]) DEFAULT [SUPPLIEDP]) 
     ;; Note that &amp;OPTIONAL arguments use the same syntax. 
     (defun* my-find (item (seq sequence) &amp;key (from-end boolean) 
                      ((test (function (t))) nil) ((test-not (function (t))) nil) 
                      ((key (function (t))) nil) (start fixnum) (end fixnum)) 
        ...function body...) </pre>
<p>
</p>
<pre>
    ;; Example of method definition. All the arguments in the arglist are 
     ;; normal 'specialised' arguments like you would usually find in a 
     ;; method definition. The form still allows you to include an assertion 
     ;; with each argument, however ('plusp' in this case). 
     (defmethod* (cell-value -&gt; real) :around ((sheet &lt;Sheet&gt;) 
                                               (x integer plusp) (y integer plusp)) 
        ...) </pre>
<p>
</p>
<pre>
    ;; Note that when you declare a return type for a method, the method 
     ;; body will perform type-checking, but no toplevel DECLAIM form will 
     ;; be generated. </pre>
<p>
</p>
<pre>
    ;; CLOS function dispatch based on classes is limited; you cannot specialise 
     ;; on user-defined types unless they are proper classes, for example. 
     ;; You may therefore sometimes want to declare that a method's argument 
     ;; is of a particular type, as well as declaring its class for specialisation 
     ;; as you normally would. 
     ;; Here is an example. Note the similarity to the syntax for keyword 
     ;; arguments. 
     (defmethod* (cell-value -&gt; real) :around ((sheet &lt;Sheet&gt;) 
                                               ((x natural plusp) integer) 
                                               ((y natural plusp) integer)) 
        ...) </pre>
<p>
</p>
<pre>
    ;; Example of DEFGENERIC*, mainly useful to declare the return type 
     ;; of a set of methods. 
     (defgeneric* (cell-value -&gt; real) (sheet x y)) </pre>
<p>
</p>
<pre>
    ;; DEFGENERIC* can also be used to declare types of arguments. Be careful 
     ;; that these don't clash with specialisers in method definitions. 
     (defgeneric* (cell-value -&gt; real) (sheet (x natural) (y natural))) </pre>
<p>
</p>
<h4>
Examples of DEFVAR* and DEFPARAMETER*: </h4>
<pre>
    (defvar* (*user-name* string) &quot;Bob&quot;) 
     (defparameter* (*file-position* (integer 0)) 0) </pre>
<p>
</p>
<h4>
Limitations: </h4>
<ul>
<li>
<p>
Definitions of SETF methods cannot include return type declarations in the 
 method 'header'. The return type can still be declared using a (RETURNS ...) 
 form. For example: 
 </p>
<pre>
    (defmethod (setf (foo -&gt; integer)) (...args...)   ; illegal 
        ...) </pre>
</li>
</ul>
<pre>
    (defmethod (setf foo) (...args...) 
        (returns integer)                  ; legal 
        ...) </pre>
</div>
</div>
<div class="defconstant">
<div class="defunsignatures">
<a id="_g6">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
+defun*-arrow-symbol+&nbsp;&nbsp;</td>
<td class="lambda-list">
'-&gt;</td>
<td class="symbol-type">
&nbsp;[Constant]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
The symbol that separates function name from type declaration 
 in DEFUN* forms and the like. See {defmacro defstar:defun*}. 
 </p>
</div>
</div>
<div class="defparam">
<div class="defunsignatures">
<a id="_g7">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
*check-argument-types-explicitly?*&nbsp;&nbsp;</td>
<td class="lambda-list">
</td>
<td class="symbol-type">
&nbsp;[Variable]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Description: </h4>
<p>
If non-nil, insert 'CHECK-TYPE' clauses in the preamble of functions, 
 to force the function's arguments to be type-checked. 
 </p>
<p>
Technically, DECLARE, DECLAIM and the like do not actually check that 
 values stored in the associated variables conform to the declared type. 
 They merely constitute a promise BY THE PROGRAMMER that only values of 
 the specified type will be stored there. The consequences of storing 
 a string in a variable that is declared to be of type integer, are 
 undefined. 
 </p>
<p>
In practise, essentially all modern lisps do perform type checking 
 based on declarations, especially when the SAFETY setting is high. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g3">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defstar/split-defun-body&nbsp;&nbsp;</td>
<td class="lambda-list">
body</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Arguments: </h4>
<ul>
<li>
<p>
BODY: the body of a DEFUN form or similar, such as might be received 
 by a macro. 
 </p>
</li>
</ul>
<h4>
Returns: </h4>
<p>
Three values: 
 </p>
<ul>
<li>
<p>
PREAMBLE: list of declaration forms at the start of the body 
 </p>
</li>
<li>
<p>
DOCSTRING: Documentation string, if present in BODY. 
 </p>
</li>
<li>
<p>
TRUE-BODY: Actual function body with the above items removed. 
 </p>
</li>
</ul>
<h4>
Description: </h4>
<p>
Internal utility function. 
 Divide the 'preamble' of a function body from its actual body. 
 The preamble consists of declarations and a docstring. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g4">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defstar/make-keyword&nbsp;&nbsp;</td>
<td class="lambda-list">
<em>&amp;rest</em> parts</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Like MKSYMBOL, but intern the symbol in the KEYWORD package, 
 creating a keyword called <span class="keyword">
:SYMBOL. </span>

 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g5">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defstar/ampersand-symbol?&nbsp;&nbsp;</td>
<td class="lambda-list">
sym</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Predicate. Does the symbol SYM begin with an ampersand, such as &amp;ANY, 
 &amp;REST and so on? 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g8">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defun*-term&nbsp;&nbsp;</td>
<td class="lambda-list">
term last-amp-kwd <em>&amp;key</em> (def-type 'defun)</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Arguments: </h4>
<ul>
<li>
<p>
TERM: any member of an ordinary lambda list. 
 </p>
</li>
<li>
<p>
LAST-AMP-KWD: Symbol or nil. 
 </p>
</li>
<li>
<p>
DEF-TYPE: Symbol denoting the type of toplevel form that is being created. 
 The default is 'DEFUN. 
 </p>
</li>
</ul>
<h4>
Returns: </h4>
<p>
Four values: 
 </p>
<ul>
<li>
<p>
1. The term as it should be included in the final argument list for 
 the toplevel form 
 </p>
</li>
<li>
<p>
2. The declaration clause that should be included in the 
 DECLARE statement within the toplevel form's body 
 </p>
</li>
<li>
<p>
3. The type of the term, for inclusion in the argument-list of 
 the (DECLAIM (FTYPE (FUNCTION arglist RETURN-TYPE) ...)) form for a 
 function definition. 
 </p>
</li>
<li>
<p>
4. The assertion clause. 
 </p>
</li>
</ul>
<h4>
Description: </h4>
<p>
Internal function, used by <a href="defstar.html#_g11">
defun*</a>
to parse lambda list terms. 
 </p>
<p>
</p>
<h4>
See also: </h4>
<ul>
<li>
<p>
<a href="defstar.html#_g11">
defun*</a>

 </p>
</li>
</ul>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g9">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
safe-define&nbsp;&nbsp;</td>
<td class="lambda-list">
toplevel-form-name fname arglist body</td>
<td class="symbol-type">
&nbsp;[Function]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Arguments: </h4>
<ul>
<li>
<p>
TOPLEVEL-FORM-NAME: Symbol denoting the type of toplevel form being defined. 
 Currently handles 'DEFUN, 'DEFMETHOD, 'FLET, 'LABELS, 'LAMBDA, 'DEFGENERIC. 
 </p>
</li>
<li>
<p>
FNAME, ARGLIST, BODY: see DEFUN*. 
 </p>
</li>
</ul>
<h4>
Returns: </h4>
<p>
A `defun', `defmethod', `defgeneric' or `lambda' form, or `flet' or 
 `labels' subclause, with appropriate declarations. 
 </p>
<p>
</p>
<h4>
Description: </h4>
<p>
Internal function. The workhorse for the macros DEFUN*, DEFMETHOD*, 
 LAMBDA*, FLET*, and LABELS*. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g10">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defvar/param&nbsp;&nbsp;</td>
<td class="lambda-list">
toplevel-form-name var value <em>&amp;optional</em> docstring</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Internal macro, used by <a href="defstar.html#_g14">
defvar*</a>
and 
 {defmacro defstar:defparameter*}. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g11">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defun*&nbsp;&nbsp;</td>
<td class="lambda-list">
fname arglist <em>&amp;body</em> body</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Arguments: </h4>
<ul>
<li>
<p>
FNAME: either the name of the function to be created, or a list as specified 
 below: 
 </p>
<pre>
    fname =   FUNCTION-NAME 
             | (FUNCTION-NAME -&gt; TYPE [assertion]) 
     assertion =       FORM 
                     | PREDICATE-SYMBOL </pre>
<p>
Where: 
 </p>
<ul>
<li>
<p>
TYPE is any valid type specifier 
 </p>
</li>
<li>
<p>
FORM is any form, which must return non-nil if the assertion is satisfied, 
 nil otherwise. Within the form, the symbol RETURN-VALUE is bound to the 
 value that is about to be returned by the function. 
 </p>
</li>
<li>
<p>
PREDICATE-SYMBOL is a symbol, the name of a function that accepts a single 
 arguments. Equivalent to the form `(PREDICATE-SYMBOL RETURN-VALUE)'. 
 </p>
</li>
</ul>
</li>
</ul>
<p>
Note that if the latter (list) form for fname is used, the DEFUN* body may NOT 
 also contain a `returns' form. Also note that the latter form cannot currently 
 be used when defining a `(setf ...)' function or method. 
 </p>
<p>
</p>
<ul>
<li>
<p>
ARGLIST: a DEFUN* LAMBDA LIST, which takes the form: 
 </p>
<pre>
    arglist =   var-term* 
               | (var-term* [&amp;optional opt-term+]) 
               | (var-term* [&amp;key opt-term+]) 
               | (var-term* [&amp;rest rest-term]) 
     var-term =        VARNAME 
                     | (VARNAME TYPE/CLASS [assertion]) 
     rest-term =       VARNAME 
                     | (VARNAME ELEMENT-TYPE) 
     opt-term =        VARNAME 
                     | (var-term DEFAULT [SUPPLIEDP]) </pre>
</li>
</ul>
<ul>
<li>
<p>
BODY: Body of the function form. This may contain a docstring in the usual 
 place, and may also a single special form beginning with `returns': 
 </p>
</li>
</ul>
<pre>
    returns-form = (RETURNS TYPE [assertion]) </pre>
<p>
If the `returns' form contains an assertion, then within that assertion, 
 the symbol `RETURN-VALUE' is bound to the value that the function is 
 about to return. 
 </p>
<p>
</p>
<h4>
Description: </h4>
<p>
Equivalent to (DEFUN fname arglist . body), but: 
 </p>
<ul>
<li>
<p>
All type declarations within the lambda list will be turned into (DECLARE...) 
 forms within the function body 
 </p>
</li>
<li>
<p>
If a return type is declared for the function itself, this will be turned 
 into a global DECLAIM form that precedes the function 
 </p>
</li>
<li>
<p>
All assertions within the lambda list will be checked before the function body 
 is entered. 
 </p>
</li>
<li>
<p>
Any assertion within a `returns' form will be checked before the function 
 returns a value. 
 </p>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    ;; Very simple example 
     (defun* (add -&gt; real) ((a real) (b real)) 
       (+ a b)) </pre>
<p>
</p>
<pre>
    ;; Example with assertion for 'b' argument, checked before the 
     ;; body of the function is entered. 
     (defun* div ((a real) (b real (/= b 0))) 
        (returns real) 
        (/ a b)) </pre>
<p>
</p>
<pre>
    (defun* sum (&amp;rest (nums real))  ; type of 'rest' var refers to 
        (returns real)                ; the type of each list element, ie 
        (apply #'+ nums))             ; nums must be a list of REALs </pre>
<p>
</p>
<pre>
    (defun* (sum -&gt; real) (&amp;rest (nums real))  ; alternative form 
        (apply #'+ nums))                       ; for above example </pre>
<p>
</p>
<pre>
    ;; This function and first argument have no type declarations. 
     ;; Keyword argument 'test' accepts a function that takes 
     ;; two arguments of any type. 
     (defun* find-in-tree (item (tree cons) 
                           &amp;key ((test (function (t t))) #'equal)) 
      (or (funcall test item tree) 
          (and (consp tree) 
               (or (find-in-tree item (car tree)) 
                   (find-in-tree item (cdr tree)))))) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g12">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defmethod*&nbsp;&nbsp;</td>
<td class="lambda-list">
fname method-arglist <em>&amp;body</em> body</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Arguments: </h4>
<p>
Usage is exactly the same as {defmacro defstar:defun*}, except that within 
 METHOD-ARGLIST, any list in a non-optional position is assumed to be a 
 specialised lambda list term of the form (VARNAME CLASS [assertion]), rather than a 
 DEFUN* type-declaring term. 
 </p>
<p>
The syntax of METHOD-ARGLIST is therefore: 
 </p>
<pre>
    arglist =   method-term* 
               | (method-term* [&amp;optional opt-term+]) 
               | (method-term* [&amp;key opt-term+]) 
               | (method-term* [&amp;rest rest-term]) 
     method-term = VARNAME 
                   | (VARNAME CLASS [assertion]) 
                   | ((VARNAME TYPE/CLASS [assertion]) CLASS) </pre>
<p>
The rest of the syntax is the same as for DEFUN*. 
 </p>
<p>
</p>
<h4>
Description: </h4>
<p>
Equivalent to (DEFMETHOD FNAME METHOD-ARGLIST . body) with type declarations 
 and assertions as per {defmacro defstar:defun*}. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (deftype positive-integer () `(integer 1)) 
     (defmethod (make-coords -&gt; (cons positive-integer positive-integer)) 
                    (((x positive-integer) integer) 
                     ((y positive-integer) integer)) 
        (cons x y)) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g13">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defgeneric*&nbsp;&nbsp;</td>
<td class="lambda-list">
fname generic-arglist <em>&amp;body</em> options</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Arguments: </h4>
<p>
Usage is exactly the same as {defmacro defstar:defun*}, except that: 
 </p>
<ul>
<li>
<p>
Assertions are ignored. 
 </p>
</li>
<li>
<p>
&amp;REST, &amp;KEY and &amp;OPTIONAL arguments must be of the form: 
 </p>
<pre>
    arg =   VARNAME 
           | (VARNAME TYPE) </pre>
</li>
</ul>
<h4>
Examples: </h4>
<pre>
    (defgeneric* (length -&gt; integer) (seq &amp;key start) ...options...) </pre>
<p>
</p>
<pre>
    ;; Note that you can declare types for arguments in the generic function 
     ;; argument list. Be careful that these do not clash with method definitions. 
     ;; Type declarations for generic function arguments will only be used to 
     ;; make a toplevel DECLAIM form that will then apply to all methods of 
     ;; the generic function. 
     (defgeneric* (length -&gt; integer) ((seq sequence) &amp;key (start integer)) 
        ...options...) </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g14">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defvar*&nbsp;&nbsp;</td>
<td class="lambda-list">
var value <em>&amp;optional</em> docstring</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Arguments: </h4>
<ul>
<li>
<p>
VAR can be either: 
 </p>
<ul>
<li>
<p>
1. A variable name: in this case DEFVAR* has exactly the same effect as 
 DEFVAR. 
 </p>
</li>
<li>
<p>
2. (VARNAME TYPE) where VARNAME is a variable name and TYPE is a type 
 declaration. 
 </p>
</li>
</ul>
</li>
<li>
<p>
VALUE: A form which is evaluated when the variable is first created. 
 </p>
</li>
<li>
<p>
DOCSTRING: Documentation. 
 </p>
</li>
</ul>
<h4>
Returns: </h4>
<p>
The name of the variable as a symbol. 
 </p>
<p>
</p>
<h4>
Description: </h4>
<p>
Creates the global special variable VAR, initialises it to VALUE, 
 and declares it to be of type TYPE, if given. 
 </p>
<p>
</p>
<h4>
Examples: </h4>
<pre>
    (defvar* (*file-name* string) &quot;~/log.txt&quot;)  </pre>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g15">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
defparameter*&nbsp;&nbsp;</td>
<td class="lambda-list">
var value <em>&amp;optional</em> docstring</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<p>
Like {defmacro defstar:defvar*}, but equivalent to DEFPARAMETER rather than DEFVAR. 
 See <a href="defstar.html#_g14">
defvar*</a>
for usage. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g16">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
flet*&nbsp;&nbsp;</td>
<td class="lambda-list">
clauses <em>&amp;body</em> body</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Description: </h4>
<p>
Like FLET, but within each clause the function name, arglist and body have the 
 same syntax as for {defmacro defstar:defun*}. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g17">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
labels*&nbsp;&nbsp;</td>
<td class="lambda-list">
clauses <em>&amp;body</em> body</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Description: </h4>
<p>
Like LABELS, but within each clause the function name, arglist and body have the 
 same syntax as for {defmacro defstar:defun*}. 
 </p>
</div>
</div>
<div class="defun">
<div class="defunsignatures">
<a id="_g18">
</a>
<table cellpadding="0" cellspacing="0" width="100%">
<colgroup span="3">
<col width="0*"/>
<col width="1*"/>
<col width="0*"/>
</colgroup>
<tbody>
<tr>
<td class="symbol-name">
lambda*&nbsp;&nbsp;</td>
<td class="lambda-list">
arglist <em>&amp;body</em> body</td>
<td class="symbol-type">
&nbsp;[Macro]</td>
</tr>
</tbody>
</table>
</div>
<div class="doc-body">
<h4>
Description: </h4>
<p>
Like LAMBDA, but the arglist and body have the same syntax as for {defmacro 
 defstar:defun*}. A `returns' form can be used within the function body to 
 declare its return type. 
 </p>
</div>
</div>
</div>
<div class="cludg-footer">
Generated by&nbsp;<a href="mailto:ihatchondo@common-lisp.net" lang="en">
CLDOC</a>
- 2010-02-06 10:41:19</div>
</body>
</html>
